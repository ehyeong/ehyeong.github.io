---
layout: post
title:  "Spring Boot Inflearn 05"
excerpt: "스프링 DB 접근 기술"
date:   2023-07-02 21:30:36 +0530
categories: SpringBoot
---

### 스프링 DB 접근 기술

### H2 데이터베이스 설치

H2 Database Engine Download (all platforms)

terminal - h2 - bin 

$ chmod 755 h2.sh

$ ./h2.sh

입력 -> 다음 창 띄워짐

http://218.38.137.27:8082/?key=748cc909652350a6fed357f69cc23fc45e921665597e15eada65afa299f13aa7

앞부분 지우고 localhost:8082/? ... 되도록 고침 

H2 콘솔 창

연결 후 나가기
 
홈에 test.mv.db 있는지 확인 (완료)

jdbc URL : jdbc:h2:tcp://localhost/~/test 로 변경
(이렇게 변경해야 여러군데에서 접근 가능함)

***

다시

rm test.mv.db (지우기)

https://www.h2database.com/html/download-archive.html 여기 들어가서 1.4.200 버전으로 다시 설치

윗 내용 반복

create table member
(
   id bigint generated by default as identity,
   name varchar(255),
   primary key (id)
); 

실행 -> 갱신된 개수: 0
(5 ms)

select * from member; -> 조회 가능

id (자바에서는 Long, DB 에서는 bigint)

id bigint generated by default as identity
: null값 (값을 세팅하지 않았다면) db가 값을 채워줌

insert into member(name) values('spring') 실행

select * from member; 확인 

ID | NAME
1 | spring

insert into member(name) values('spring2') -> 

2 | spring2 

추가

db 끄면 안됨! (다시 접속해야함)

***

### 순수 JDBC

데이터 저장 기술의 발전

build.gradle 파일에 jdbc, h2 db 관련 라이브러리 추가

```java

implementation 'org.springframework.boot:spring-boot-starter-jdbc'

runtimeOnly 'com.h2database:h2' 

```

application.properties 파일

```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test

spring.datasource.driver-class-name=org.h2.Driver

```

추가

repository - JdbcMemberRepository 추가

(복붙)

```java

package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;
    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql,
                    Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName());
            pstmt.executeUpdate();
            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;

        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
            rs = pstmt.executeQuery();
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        } }
    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();

            List<Member> members = new ArrayList<>();
            while(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }
    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
    {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } try {
        if (pstmt != null) {
            pstmt.close();
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } }
    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);
    }
}

```

SpringConfig

```java
@Bean
    public MemberRepository memberRepository(){
//        return new MemoryMemberRepository();
        return new JdbcMemberRepository();
    }
```

수정

```java
private DataSource dataSource;

    @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

```

memberRepository()에 dataSource 추가

```java
return new JdbcMemberRepository(dataSource);
```

실행

⚠️ Whitelabel Error 오류 발생

회원 목록 -> 에러

(이유를 모르겠어서 많은 시간 투자 ...)
스프링부트 2.4 이후로 추가 필수
application.properties 
```java
spring.datasource.username=sa 
```    
추가 -> 해결!

스프링부트 2.4 이후로 추가 필수 (버전간의 문제였음)

📌 확인

원래는 (기존)

MemberService는 MemberRepository를 의존하고 있음

MemberRepository는 MemoryMemberRepository와 JdbcMemberRepository가 있음

스프링 컨테이너에서는
memory를 지우고 jdbc 로 연결을 바꿈

```
-> **개방폐쇄 원칙** (OCP, Open-Closed Principle)
    확장에는 열려있고, 수정.변경에는 닫혀있음

-> 스프링의 DI(Dependencies Injection)을 사용하면 기존 코드를 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있음

=> 재실행해도 데이터가 남아있는 것을 확인할 수 있음
```

***

### 스프링 통합 테스트

test - service - MemberServiceTest 복사

MemberServiceIntegrationTest 생성

```java
@SpringBootTest
@Transactional
```
Spring 컨테이너한테 memoryMemberRepository 내놔 해야함.  
```java
@BeforeEach
    public void beforeEach(){
        memberRepository = new MemoryMemberRepository();
        memberService = new MemberService(memberRepository);
    }


    @AfterEach
    public void afterEach(){
        memberRepository.clearStore();
    }
```
지우기

```java
@Autowired MemberService memberService;
@Autowired MemberRepository memberRepository;
```

추가

회원가입 실행 (잠시 Transactional 주석처리)

-> db에 hello 들어감

다시 실행 -> 오류 ! (당연함 이미 db에 hello를 넣어둠)

```java
📎 @Transactional
```
을 달면 test를 실행할 때 transaction을 실행하고 db의 데이터를 insert quary에 넣은 후 test가 끝나면 롤백을 해줌! 깨끗하게 지워짐

delete from member;

db를 모두 지우고 다시 실행 (Transactional 주석 풀어줌)

-> 실행 O -> 다시 실행 O (db에 값 없음. 롤백하여 다 지워줌 -> 다음 테스트 중복 다시 가능)

📌 확인

```
📎 @SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행한다.
📎 @Transactional : 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다.
```

***

### 스프링 JdbcTemplate

- MyBatis와 비슷한 라이브러리

- 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거

- 하지만 SQL은 직접 작성

repository - JdbcTemplateMemberRepository 생성

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;

import java.util.List;
import java.util.Optional;

public class JdbcTemplateMemberRepository implements MemberRepository{
    @Override
    public Member save(Member member) {
        return null;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.empty();
    }

    @Override
    public Optional<Member> findByName(String name) {
        return Optional.empty();
    }

    @Override
    public List<Member> findAll() {
        return null;
    }
}
```
다음 추가

```java
private final JdbcTemplate jdbcTemplate;

    @Autowired
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }
```

생성자가 딱 하나일 때 @Autowired 생략 가능

```java
private RowMapper<Member> memberRowMapper(){
        return new RowMapper<Member>() {
            @Override
            public Member mapRow(ResultSet rs, int rowNum) throws SQLException {

                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return member;
            }
        };
    }
```
lambda로 고치기

```java
private RowMapper<Member> memberRowMapper(){
        return (rs, rowNum) -> {

            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
```

findById 수정

```java
@Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }
```

(이해 못함)

앞에서 사용한 jdbc를 잘 정리하여 줄인 것이 이 템플릿

```java
@Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());
        Number key = jdbcInsert.executeAndReturnKey(new
                MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }
```
(복붙)

findByName 은 findById에서 id -> name 교체

```java
@Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        return result.stream().findAny();
    }
```

findAll

```java
return jdbcTemplate.query("select * from member", memberRowMapper());
```
추가

SpringConfig

```java
//return new JdbcMemberRepository(dataSource); 
return new JdbcTemplateMemberRepository(dataSource);
``` 
JdbcMemberRepository 주석 후 JdbcTemplateMemberRepository 반환

실행 -> 성공!

📌 확인

***

### JPA

(강의 *자바 ORM 표준 JPA 프로그래밍 - 기본편*)

- JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
- JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환을 할 수 있다. 
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다.

build.gradle

```java
//	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
implementation 'org.springframework.boot:spring-boot-starter-data-jpa:2.7.13'
```
application.properties

```java
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```
추가

domain - Member

@Entity 

@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)

추가

identity -> id값은 알아서 지정해줌

```java
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    ...
}
```

repository - JpaMemberRepository 생성

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import jakarta.persistence.EntityManager;

import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository{


    @Override
    public Member save(Member member) {
        return null;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.empty();
    }

    @Override
    public Optional<Member> findByName(String name) {
        return Optional.empty();
    }

    @Override
    public List<Member> findAll() {
        return null;
    }
}
```
option + Enter

```java
    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }
```
추가

jpa를 쓰기 위해선 EntityManager를 주입 받아야함.

save 수정

```java
@Override
    public Member save(Member member) {
        em.persist(member);
        return member;
    }
```

id까지 member에서 다해줌

findById 수정

```java
@Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }
```
findAll 수정

```java
@Override
    public List<Member> findAll() {
        em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }
```
option + Enter , result 로 수정 ->

```java
@Override
    public List<Member> findAll() {
        List<Member> result = em.createQuery("select m from Member m", Member.class)
                .getResultList();
        return result;
    }
```
inline으로 다시 수정 (왜 이렇게 하는지 모르겠음)

```java
return em.createQuery("select m from Member m", Member.class)
                .getResultList();
```

select m -> 객체 자체 m을 select 함

findByName
```java
@Override
    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();

        return result.stream().findAny();
    }
```
전체
```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import jakarta.persistence.EntityManager;

import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository{

    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();

        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }
}
```

jpa를 쓰기 위해선 @Transational이 있어야함
-> 데이터 저장, 변경

MemberService 에 @Transactional 추가

service - SpringConfig

```java
  @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }
```
삭제

```java
private EntityManager em;

    @Autowired
    public SpringConfig(EntityManager em) {
        this.em = em;
    }
```
추가

memberRepository 수정

```java
//        return new JdbcTemplateMemberRepository(dataSource);
        return new JpaMemberRepository(em);
```

실행 -> ⚠️ 에러 

해결 (이것저것 다 해서 어디서 고쳐졌는지 모르겠음)

@Commit 을 넣고 MemberServiceIntegrationTest 실행 -> spring 들어가는 것 확인할 수 있음

📌 확인

***

### 스프링 데이터 JPA

repository - SpringDataJpaMemberRepository 인터페이스 생성

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface SpringDataJpaMemberRepository extends JpaRepository<Member,Long>, MemberRepository {

    @Override
    Optional<Member> findByName(String name);
}
```
service - SpringConfig

```java
/*
    private final DataSource dataSource;
    private final EntityManager em;
    public SpringConfig(DataSource dataSource, EntityManager em) {
        this.dataSource = dataSource;
        this.em = em;
    }

 */
```
주석처리

memberRepository()도 주석처리

```java
private final MemberRepository memberRepository;

@Autowired
public SpringConfig(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
    }
```
생성

실행 -> 성공

📌 확인

스프링 데이터 JPA 가 SpringDataJpaMemberRepository를 스프링 빈으로 자동 등록

JpaRepository를 들어가보면 기본 메소드를 다 제공해줌 (crud) *공통* -> 가져와 쓰면 됨

공통이 불가능한 것 -> findByName 인터페이스로

**스프링 데이터 JPA 제공 기능** 
- 인터페이스를 통한 기본적인 CRUD
findByName() 
- findByEmail() 처럼 메서드 이름 만으로 조회 기능 제공 
- 페이징 기능 자동 제공
